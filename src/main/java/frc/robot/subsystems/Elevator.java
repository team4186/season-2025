package frc.robot.subsystems;
import com.revrobotics.spark.SparkLowLevel;
import com.revrobotics.spark.SparkMax;
import com.revrobotics.RelativeEncoder;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj.DigitalInput;
import frc.robot.sparkmaxconfigs.Components;
import frc.robot.sparkmaxconfigs.MotorSet;

public class Elevator {

    // Motor, Encoder, and Limit Switches variables
    private MotorSet elevatorMotors = Components.getInstance().elevatorMotors;
    private RelativeEncoder encoder;

    // Make id # correct
    private DigitalInput bottomLimitSwitch = new DigitalInput(2);
    private DigitalInput topLimitSwitch = new DigitalInput(3);

    private PIDController pid;

    private int level;
    private double currentElevatorHeight;
    private final double LEVEL_ONE_HEIGHT = 5; //Change the level heights here
    private final double LEVEL_TWO_HEIGHT = 10;
    private final double LEVEL_THREE_HEIGHT = 15;
    private final double DEFAULT_FREE_MOVE_SPEED = 0.4;
    private final double DEFAULT_FREE_MOVE_DOWN_SPEED = 0.1;
    private final double DEFAULT_SETPOINT_THRESHOLD = 2.5;

    public Elevator(int elevatorMotor1ID, int elevatorMotor2ID, PIDController pidParam) {
        encoder = elevatorMotors.getLeadEncoder();

        pid = pidParam;
        currentElevatorHeight = 0;
    }

    /*
        This is the thing we can do to find the distance the motor has traveled.

        To get the distance traveled from a bore encoder, you need to count the number of pulses generated by the encoder and multiply that number by the "distance per pulse" which is calculated based on the circumference of the bore and the encoder's resolution (pulses per revolution) - essentially, converting the rotational movement of the bore into a linear distance traveled.
Key steps:
Measure the bore circumference: This is the distance traveled for one full rotation of the bore.
Find the encoder resolution: This is the number of pulses the encoder generates per revolution.
Calculate "distance per pulse": Divide the bore circumference by the encoder resolution.
Read encoder pulses: In your control system, read the number of pulses generated by the encoder.
Calculate distance traveled: Multiply the "distance per pulse" by the number of encoder pulses rea
         */

    public void goToLevel(int controllerInput) {
        level = controllerInput; // controllerInput is 1, 2, or 3
        double distanceToLevel;

        switch (level) {
            case 1:
                distanceToLevel = LEVEL_ONE_HEIGHT - getHeight();
                goUp(1, distanceToLevel, LEVEL_ONE_HEIGHT);
                break;
            case 2:
                distanceToLevel = LEVEL_TWO_HEIGHT - getHeight();
                goUp(2, distanceToLevel, LEVEL_TWO_HEIGHT);
                break;
            case 3:
                distanceToLevel = LEVEL_THREE_HEIGHT - getHeight();
                goUp(3, distanceToLevel, LEVEL_THREE_HEIGHT);
                break;
        }
    }

    public void goUp(int level, double distanceToLevel, double height) {
        //double speed = pid.calculate(position, height).coerceIn(-DEFAULT_FREE_MOVE_SPEED, DEFAULT_FREE_MOVE_SPEED);

        if (distanceToLevel == 0) {
            setHeight(height);
            stopMotor();
        } else {
            elevatorMotors.setSpeed(-0.2);
        }
    }

    public void goDown() {
        if (!bottomLimitSwitch.get()) {  //might have to change if bottomLimitSwitch is false when activated
            elevatorMotors.setSpeed(-0.2);
        } else {
            setHeight(0.0);
            stopMotor();
        }
    }

    public void stopMotor() {
        elevatorMotors.stop();
        pid.reset();
    }

    public double getHeight() {
        return currentElevatorHeight;
    }

    // stops height from being set to an impossible height.
    public void setHeight(double height) {
        if (height > 0 && height < 20) { // 20 should be changed to max height
            currentElevatorHeight = height;
        }
    }
}